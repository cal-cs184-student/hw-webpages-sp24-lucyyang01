<html>
	<head>
	  <meta charset="UTF-8">
	  <meta name="viewport" content="width=device-width, initial-scale=1.0">
	  <title>Homework 2</title>
	  <style>
	    /* CSS for styling */
	    body {
	      font-family: Arial, sans-serif;
	      line-height: 1.6;
	      margin: 0;
	      padding: 0;
	    }
	    header {
	      background-color: #dd8ea4;
	      color: #fff;
	      padding: 20px;
	      text-align: center;
	    }
	    section {
	      padding: 20px;
	    }
	    h2 {
	      color: #fff; /* Changing text color to contrast with background */
	      text-align: center;
	    }
	    .subsection-content {
	      background-color: #f9f9f9;
	      border: 1px solid #ccc;
	      padding: 10px;
	      border-radius: 5px;
	    }
	    img {
	      max-width: 100%; /* Ensure images don't exceed their container's width */
	      height: auto; /* Maintain aspect ratio */
	      display: block; /* Remove any extra space below images */
	      margin: 0 auto 20px; /* Add margin for spacing */
	      border-radius: 5px; /* Add rounded corners */
	      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Add a subtle box shadow */
	    }
	  </style>
	</head>
	<body>
		<header>
		  	<h1>Homework 2: Meshed It</h1>
		 	<p>By Lucy Yang and Nicole Leung</p>
		</header>

		<section>
			<header>
				<h2>Overview</h2>
			</header>
			<div class="subsection-content">
				<p> </p>
			    <p> </p>
			</div>
		</section>

		<section>
			<header>
				<h2>Part 1: Bezier Curves with 1D de Casteljau Subdivision</h2>
			</header>
			<div class="subsection-content">
				  <p>De Casteljau's Algorithm</p>
				  <p>De Casteljau’s algorithm takes in a set of control points that define the Bezier curve and a parameter, t, which is a 
					fraction less than one. The algorithm recursively finds intermediate points between adjacent control points of the same 
					level until only one point remains, using t to determine the location of the intermediate points. In `evaluateStep(...)` 
					we used the equation given in the spec and the given arguments to find the intermediate control points that lie between 
					the given control points and return these values in the form of an std::vector.
				  </p>
				<img src="../images/[184] hw2_pngs/[Bez] control_points.png" alt="Description of the image">
				<img src="../images/[184] hw2_pngs/[Bez] level_one.png" alt="Description of the image">
				<img src="../images/[184] hw2_pngs/[Bez] level_two.png" alt="Description of the image">
				<img src="../images/[184] hw2_pngs/[Bez] level_three.png" alt="Description of the image">
				<img src="../images/[184] hw2_pngs/[Bez] level_four.png" alt="Description of the image">
				<img src="../images/[184] hw2_pngs/[Bez] level_five.png" alt="Description of the image">
				<p> Completed Bezier Curve </p>
				<img src="../images/[184] hw2_pngs/[Bez] toggle.png" alt="Description of the image">
				<p> Altered Bezier Curve </p>
				<img src="../images/[184] hw2_pngs/[Bez] altered.png" alt="Description of the image">
			</div>
		</section>

		<section>
			<header>
				<h2>Part 3: Area-Weighted Vertex Normals</h2>
			</header>
			<div class="subsection-content">
				<p>In order to find the area-weighted vertex normals, we traversed every halfedge associated with the vertex and added 
					the normal and area of the face related to each halfedge to a respective std::vector. We then used these values to find 
					the weighted average of the normal vectors with respect to the fraction of their face-area divided by the sum of all 
					neighboring face-areas.
				</p>
				<img src="../images/[184] hw2_pngs/[Tea] flat.png" alt="Description of the image">
				<img src="../images/[184] hw2_pngs/[Tea] phong.png" alt="Description of the image">
			</div>
		</section>

		<section>
			<header>
				<h2>Part 5: Edge Split</h2>
			</header>
			<div class="subsection-content">
				<p>We first labeled the existing halfedges in the corresponding mesh segment. Then we created a new vertex, three new edges, 
					six new halfedges, and two new faces. We reassigned the pointers accordingly in order for the mesh to resemble the correct 
					“splitEdge” result. One debugging trick we used religiously was to comment out specific blocks of code, and then re-run 
					the program in order to pinpoint what could be causing the error. Additionally changing only one attribute at a time allowed 
					us to see how each pointer reassignment affected the resulting performance of splitEdge.
				</p>
				<p>Before and after edge splits:</p>
				<img src="../images/[184] hw2_pngs/[Quad] before split.png" alt="Description of the image">
				<img src="../images/[184] hw2_pngs/[Quad] after split.png" alt="Description of the image">
				<p>Before and after edge splits and flips:</p>
				<img src="../images/[184] hw2_pngs/[Bean] before_split_flip.png" alt="Description of the image">
				<img src="../images/[184] hw2_pngs/[Bean] after_split_flip.png" alt="Description of the image">
				<p>After implementing splitEdge we realized that splitting an edge multiple times, or splitting and then flipping an edge, 
					led to a blank hole, as if the face of that particular edge disappeared. After confirming the logic of our implementation 
					we ended up pinpointing the problem to our pointer reassignments. After changing multiple things that we believed could be 
					the issue (vertex-halfedge pairs, face-halfedge pairs, etc.) we re-analyzed how we used setNeighbors to reassign the 
					halfedge elements. It turns out we had been labeling the wrong next-halfedge for some of the new halfedges, and were able to 
					fix this bug.
				</p>
			</div>
		</section>


	

	
	</body>
</html>